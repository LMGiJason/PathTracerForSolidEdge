<?xml version="1.0"?>
<doc>
<assembly>
<name>
PathTraceforSolidEdge
</name>
</assembly>
<members>
<member name="T:PathTrace.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:PathTrace.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:PathTrace.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="T:PathTrace.OleMessageFilter">
 <summary>
 Class that implements the OLE IMessageFilter interface.
 </summary>
</member>
<member name="M:PathTrace.OleMessageFilter.#ctor">
 <summary>
 Private constructor.
 </summary>
 <remarks>
 Instance of this class is only created by Register().
 </remarks>
</member>
<member name="M:PathTrace.OleMessageFilter.Finalize">
 <summary>
 Destructor.
 </summary>
</member>
<member name="M:PathTrace.OleMessageFilter.Register">
 <summary>
 Registers this instance of IMessageFilter with OLE to handle concurrency issues on the current thread. 
 </summary>
 <remarks>
 Only one message filter can be registered for each thread.
 Threads in multithreaded apartments cannot have message filters.
 Thread.CurrentThread.GetApartmentState() must equal ApartmentState.STA. In console applications, this can
 be achieved by applying the STAThreadAttribute to the Main() method. In WinForm applications, it is default.
 </remarks>
</member>
<member name="M:PathTrace.OleMessageFilter.Unregister">
 <summary>
 Unregisters a previous instance of IMessageFilter with OLE on the current thread. 
 </summary>
 <remarks>
 It is not necessary to call Unregister() unless you need to explicitly do so as it is handled
 in the destructor.
 </remarks>
</member>
<member name="T:PathTrace.IMessageFilter">
 <summary>
 Provides COM servers and applications with the ability to selectively handle incoming and outgoing COM
 messages while waiting for responses from synchronous calls.
 </summary>
 <remarks>http://msdn.microsoft.com/library/windows/desktop/ms693740.aspx</remarks>
</member>
<member name="M:PathTrace.IMessageFilter.HandleInComingCall(System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
 <summary>
 Provides a single entry point for incoming calls.
 </summary>
 <remarks>http://msdn.microsoft.com/library/windows/desktop/ms687237.aspx</remarks>
</member>
<member name="M:PathTrace.IMessageFilter.MessagePending(System.IntPtr,System.Int32,System.Int32)">
 <summary>
 Indicates that a message has arrived while COM is waiting to respond to a remote call.
 </summary>
 <remarks>http://msdn.microsoft.com/library/windows/desktop/ms694352.aspx</remarks>
</member>
<member name="M:PathTrace.IMessageFilter.RetryRejectedCall(System.IntPtr,System.Int32,System.Int32)">
 <summary>
 Provides applications with an opportunity to display a dialog box offering retry, cancel, or task-switching options.
 </summary>
 <remarks>http://msdn.microsoft.comlibrary/windows/desktop/ms680739.aspx</remarks>
</member>
<member name="T:PathTrace.PathProcessor">
 <summary>
 Does all the work of connection to Solid Edge and creating the curves
 </summary>
 <remarks></remarks>
</member>
<member name="M:PathTrace.PathProcessor.Activate">
 <summary>
 We just want the program to behave like any other Solid Edge command so we have all this code below
 </summary>
 <remarks></remarks>
</member>
<member name="T:PathTrace.PreciseTrackBar">
 <summary>
 Just an implementation of a TrackBar that returns a floating point value of a range
 </summary>
 <remarks></remarks>
</member>
</members>
</doc>
